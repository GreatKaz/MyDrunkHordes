<!doctype html>
<html lang="fr">
<head>
  <link rel="icon" href="favicon.ico">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MyDrunkHordes</title>
  <style>
    :root { color-scheme: dark light; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0; padding: 24px;
      background: #0b0f14;
      color: #e8eef7;
    }
    .wrap { max-width: 900px; margin: 0 auto; }
    h1 { font-size: 20px; margin: 0 0 16px; font-weight: 700; }
    .card {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    textarea {
      width: 100%;
      min-height: 140px;
      resize: vertical;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.25);
      color: #e8eef7;
      outline: none;
      line-height: 1.4;
      font-size: 14px;
      box-sizing: border-box;
    }
    textarea:focus { border-color: rgba(112, 168, 255, 0.7); }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
      margin-top: 14px;
    }
    @media (min-width: 840px) {
      .grid { grid-template-columns: 1.15fr 0.85fr; }
    }
    .section-title { font-size: 13px; opacity: 0.9; margin: 0 0 8px; }
    .lists {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .check {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      user-select: none;
    }
    .check input { transform: scale(1.1); }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
    }
    .slider-row { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    input[type="range"] { width: 100%; }
    .pill {
      display: inline-flex;
      align-items: center;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.25);
      font-size: 12px;
      white-space: nowrap;
    }
    button {
      cursor: pointer;
      border: 0;
      padding: 12px 14px;
      border-radius: 12px;
      font-weight: 700;
      background: linear-gradient(135deg, #5fb0ff, #8a5bff);
      color: #0b0f14;
    }
    button:hover { filter: brightness(1.05); }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .muted { opacity: 0.8; font-size: 12px; }
    .footer {
      margin-top: 14px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    .smallbtn {
      background: rgba(255,255,255,0.10);
      color: #e8eef7;
      border: 1px solid rgba(255,255,255,0.16);
      font-weight: 600;
    }
    .output {
      min-height: 140px;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.25);
      color: #e8eef7;
      line-height: 1.4;
      font-size: 14px;
      white-space: pre-wrap;
    }
    .output em {
      font-style: italic;
      opacity: 0.85;
    }
    .smallbtn:hover { filter: brightness(1.25); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Transformateur de texte MyDrunkHordes</h1>

    <div class="card">
      <p class="section-title">Texte d‚Äôentr√©e</p>
      <textarea id="inputText" placeholder="Colle/√©cris ton texte ici..."></textarea>

      <div class="grid">
        <div>
          <p class="section-title">Modulations actives (3)</p>
          <div class="lists" id="listsBox"></div>
        </div>

        <div class="controls">
          <div>
            <p class="section-title">Intensit√©</p>
            <div class="slider-row">
              <span class="pill">Faible</span>
              <input id="intensity" type="range" min="0" max="2" step="1" value="1" />
              <span class="pill">Accentu√©</span>
            </div>
            <div class="row">
              <span class="muted">S√©lection :</span>
              <span id="intensityLabel" class="pill">moyen</span>
            </div>
          </div>

          <button id="transformBtn">Transformer</button>

          <div class="footer">
            <button id="copyBtn" class="smallbtn" type="button">Copier le r√©sultat</button>
            <button id="copyForumBtn" class="smallbtn" type="button">Copier (forum)</button>
            <span class="muted" id="toast"></span>
          </div>
        </div>
      </div>

      <p class="section-title" style="margin-top:14px;">Texte transform√©</p>
      <div id="outputText" class="output" aria-readonly="true"></div>
    </div>
  </div>

  <script>
    // ===============
    // 1) LISTES
    // ===============
    const WORD_LISTS = [
      {
        id: "drunk",
        label: "Ivre",
        // remplacements possibles
        words: [
          "... le...", "et euuh..", " .. et je...", ".. non...", "... pis..", ".. non attend..",
          " et euh... l√†", ".. pis alors...", "... j'crois...", ".t..T..Truc...", "... la...",
          "..hein ?..", "..tu vois...", "..ou bien...", ".. un euh...", ".. non ?.. hein ?",
          "... ou pas...", ".. enfin.. tu vois quoi...", ".. bidule...", ".. voil√† quoi...",
          ".. et euh... j'disais quoi...", "... parceque tu vois...", " genre...", " style...",
          ".. raaah bordel...", ".. mais... euh..", "HIPS...", "... comment d√©j√†...", " arf.",
          "... machin..", "... le bazar l√†..", ".. le truc l√†...", "... truc..", ".. genre...",
          ".. r√¥te...", ".. bordel..", "euh...", "huh...", "..le bazar quoi...", "... parceque.."
        ],
        // insertions possibles
        inserts: [
          "... ouais...", "et euuh..", " ...", " .. et je...", " non...", "... pis..",
          ".. non attend..", " et euh... l√†", ".. pis alors...", " non ?.. Oui ?",
          "..Hi hi hi ! ...", "... j'crois...", ".gghhh...", "..hin hin...", "..H√© h√©...",
          "..hein ?", "..ou bien...", ".. Qu'est-ce que...", " non ?.. Oui ?",
          "... ou pas quoi...", ".. enfin.. tu vois quoi...", ".. ouais les gars...",
          " voil√† quoi...", ".. et euh... j'disais quoi...", "... parceque tu vois...",
          "...", " genre...", " style...", " et paf...", " mais... euh..", "* HIPS *...",
          "... comment d√©j√†...", " arf.", "... truc..", " pfff...", "...", "...", "...",
          "..", "..", "... ..."
        ]
      },
      {
        id: "terror",
        label: "Terroris√©",
        words: [
          "zombie", "cadavre", "souffrances", "atroce", "pourriture", "infection", "putride",
          "fant√¥me", "horrible", "immonde", "monstre", "tomate", "poire", "banane", "pomme",
          "tulipe", "peur", "avion", "p√©pin", "rigolo", "fleur", "youpi-banane", "avion",
          "polompolom", "sapine", "galinac√©e", "canard", "biloute", "berlingot", "patate",
          "gourde", "carotte", "sapin", "papa No√´l", "pelle", "pouic", "schtroumpfer",
          "folie", "abeille", "patapon", "lalala", "manger", "d√©vorer", "broyer"
        ],
        inserts: [
            ".. AH AH AH !...", "..vais tous vous...", "..les.. voix...", ".gghhh...", "NOOOoon !...",
            "marmonne...", "..hin hin...", "ALLEZ VOUS EN !..", "des araign√©es...",
            "..ils sont partout...", "..Lachez moi !..", ".. Ah... Ah ah..",
            ".. qui est l√† ?..", "..rrRRR... RAAAAaah !", ".r.tuer...", "...ricane..", "...",
            "..Petiiit papaa Noo.. NOOOON !!...", " et pirouette cacahu√®tes ...", "..hein ?",
            "..froid..", "..ou bien...", ".. Qu'est-ce que...", " non ?.. Oui ?",
            ". Pas du tout..", ".. Laissez moi !", "..Hi hi hi ! ...", "grogne...",
            "... Mon beau sapiiin ! ....", ".. roule petit patapon ...",
            "... toujours un beau temps au nord ...",
            ".. Alouetteuuh gentiiil.. Hein ?..",
            " car il y a longtemps que je t'aime...",
            "mon ami Pierroooot", "et ainsi font font FONT !! Ah !..."
        ]
      },
      {
        id: "head",
        label: "Bless√©",
        words: [
            "...ggh..", "tousse...", "...argh..", "..gnn..", "... je...", ".g...", "grogne...",
            "..Gn..", "..raah..", "....", " RAAH !..", "..le...", "qu.. non..."
        ],
        inserts: [
          // Je crois qu'il n'y en a pas
        ]
      },
      {
        id: "Custom",
        label: "Graines d'Opti",
        // Liste de mots rajout√©s pour les privates jokes
        words: [
          "C'est la faute √† Botaire", "Chill", "opti", "l√©gende"
        ],
        inserts: [
          // 
        ]
      }
    
    ];

    // =========================
    // 2) PARAM√àTRES D'INTENSIT√â
    // =========================
    // Sert √† scaler la "violence" des modulations
    const INTENSITY_PRESETS = [
      { name: "Faible",   scale: 0.8, sprinklePunct: 0.06 },
      { name: "Original",   scale: 1.0, sprinklePunct: 0.12 },
      { name: "Accentu√©", scale: 1.35, sprinklePunct: 0.22 }
    ];

    // ============
    // UI BUILD
    // ============
    const listsBox = document.getElementById("listsBox");
    const intensity = document.getElementById("intensity");
    const intensityLabel = document.getElementById("intensityLabel");
    const inputText = document.getElementById("inputText");
    const outputText = document.getElementById("outputText");
    const toast = document.getElementById("toast");

    function buildListsUI() {
      listsBox.innerHTML = "";
      WORD_LISTS.forEach(l => {
        const wrap = document.createElement("label");
        wrap.className = "check";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = true;
        cb.id = l.id;

        const span = document.createElement("span");
        span.textContent = l.label;

        wrap.appendChild(cb);
        wrap.appendChild(span);
        listsBox.appendChild(wrap);
      });
    }

    function updateIntensityLabel() {
      const preset = INTENSITY_PRESETS[Number(intensity.value)];
      intensityLabel.textContent = preset.name;
    }

    buildListsUI();
    updateIntensityLabel();
    intensity.addEventListener("input", updateIntensityLabel);

    // ============
    // HELPERS
    // ============
    function randInt(min, max) { // inclusive
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function pick(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function escapeHTML(str) {
      return (str ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function tokenize(text) {
      // Conserve <em>...</em> 
      return text.match(/<\/??em>|[\p{L}\p{N}‚Äô']+|\s+|[^\s\p{L}\p{N}]+/gu) || [];
    }

    function splitSentences(text) {
      const parts = text.split(/([.!?]+|\n+)/g);
      const out = [];
      for (let i = 0; i < parts.length; i += 2) {
        const chunk = (parts[i] ?? "");
        const sep = (parts[i+1] ?? "");
        out.push(chunk + sep);
      }
      return out.filter(s => s.length > 0);
    }

    function applyCaseLike(source, target) {
      if (source.toUpperCase() === source) return target.toUpperCase();
      if (source[0] && source[0].toUpperCase() === source[0]) {
        return target.charAt(0).toUpperCase() + target.slice(1);
      }
      return target;
    }

    function sprinkleExtraPunct(text, chance) {
      if (Math.random() > chance) return text;
      const tics = ["...", "!!", "?!", "‚Äî"];
      const tic = pick(tics);
      if (text.trim().endsWith(tic)) return text;
      return text.replace(/\s*$/, "") + " " + tic + " ";
    }

    function flash(btn, msg = "Copi√© ‚úÖ") {
      const old = btn.textContent;
      btn.textContent = msg;
      btn.disabled = true;
      setTimeout(() => {
        btn.textContent = old;
        btn.disabled = false;
      }, 900);
    }

    function copyToClipboard(text) {
      if (navigator.clipboard && window.isSecureContext) {
        return navigator.clipboard.writeText(text);
      }
      return new Promise((resolve, reject) => {
        try {
          const ta = document.createElement("textarea");
          ta.value = text;
          ta.setAttribute("readonly", "");
          ta.style.position = "fixed";
          ta.style.left = "-9999px";
          document.body.appendChild(ta);
          ta.select();
          const ok = document.execCommand("copy");
          document.body.removeChild(ta);
          ok ? resolve() : reject(new Error("copy failed"));
        } catch (e) {
          reject(e);
        }
      });
    }

    // Convertit le contenu HTML (avec <em>) en BBCode [i][/i]
    function outputToBBCode() {
      const root = outputText.cloneNode(true);

      function walk(node) {
        if (node.nodeType === Node.TEXT_NODE) return node.nodeValue;
        if (node.nodeType !== Node.ELEMENT_NODE) return "";

        const tag = node.tagName.toLowerCase();
        if (tag === "em") {
          let inside = "";
          node.childNodes.forEach(ch => inside += walk(ch));
          return `[i]${inside}[/i]`;
        }
        if (tag === "br") return "\n";

        let out = "";
        node.childNodes.forEach(ch => out += walk(ch));
        return out;
      }

      let result = "";
      root.childNodes.forEach(ch => result += walk(ch));
      return result;
    }

    // =========================
    // 3) MODULATIONS (bitmask)
    // =========================
    const ModulationNone   = 0;
    const ModulationDrunk  = 1 << 1; // 2
    const ModulationTerror = 1 << 2; // 4
    const ModulationHead   = 1 << 3; // 8

    function getList(id) {
      return WORD_LISTS.find(x => x.id === id);
    }

    function activeMask() {
      let mask = ModulationNone;
      if (document.getElementById("drunk")?.checked)  mask |= ModulationDrunk;
      if (document.getElementById("terror")?.checked) mask |= ModulationTerror;
      if (document.getElementById("head")?.checked)   mask |= ModulationHead;
      return mask;
    }

    function pickActiveModulation(mask) {
      const mods = [];
      if ((mask & ModulationDrunk)  === ModulationDrunk)  mods.push(ModulationDrunk);
      if ((mask & ModulationTerror) === ModulationTerror) mods.push(ModulationTerror);
      if ((mask & ModulationHead)   === ModulationHead)   mods.push(ModulationHead);
      if (mods.length === 0) return ModulationNone;
      return pick(mods);
    }

    function isWord(tok) {
      return /^[\p{L}\p{N}‚Äô']+$/u.test(tok);
    }

    function wordTokenIndexes(tokens) {
      const idxs = [];
      let inEm = false;
      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];
        if (t === "<em>")  { inEm = true; continue; }
        if (t === "</em>") { inEm = false; continue; }
        if (!inEm && isWord(t)) idxs.push(i);
      }
      return idxs;
    }

    function lenFactor(word) {
      const n = Math.max(1, word.length);
      return Math.min(2.0, n / 25.0);
    }

    // A) double-letter : injecte "X...x..." (signature drunk/terror)
    function modDoubleLetters(word, chance) {
      if (word.length < 2) return word;
      if (Math.random() > chance) return word;

      const useHead = Math.random() < 0.5;
      const idx = useHead ? 0 : randInt(0, word.length - 1);
      const ch = word[idx];

      if (!/[\p{L}]/u.test(ch)) return word;

      const lower = ch.toLowerCase();

      // proche du PHP : si idx==0 => "X...x..." + word, sinon insertion "...x..."
      if (idx === 0) {
        return `${ch}...${lower}...` + word;
      }
      return word.slice(0, idx) + `...${lower}...` + word.slice(idx);
    }

    // B) insert/replace sur mot cible
    function modInsertReplace(tokens, wordIdxToken, replaceChance, wordsPool, insertsPool) {
      if (!tokens[wordIdxToken] || !isWord(tokens[wordIdxToken])) return { didReplace: false, didInsert: false };

      const original = tokens[wordIdxToken];
      if (original.length <= 2) return { didReplace: false, didInsert: false };

      const doReplace = Math.random() < replaceChance;

      if (doReplace && wordsPool.length > 0) {
        const rep = pick(wordsPool);
        const final = applyCaseLike(original, rep);
        tokens[wordIdxToken] = `<em>${escapeHTML(final)}</em>`;
        return { didReplace: true, didInsert: false };
      }

      if (!doReplace && insertsPool.length > 0) {
        const ins = pick(insertsPool);
        const safeIns = `<em>${escapeHTML(ins)}</em>`;
        tokens.splice(wordIdxToken, 0, safeIns, " ");
        return { didReplace: false, didInsert: true };
      }

      return { didReplace: false, didInsert: false };
    }

    // C) head : insertion au milieu du mot
    function modHead(word, pool) {
      if (!isWord(word)) return word;
      if (pool.length === 0) return word;
      const ins = pick(pool);
      const pos = randInt(0, word.length);
      return word.slice(0, pos) + ins + word.slice(pos);
    }

    // ============
    // MAIN TRANSFORM 
    // ============
    function transformText(text) {
      text = escapeHTML(text);

      // ~5%: aucun changement (comme l'original)
      if (Math.random() < 0.05) {
        return { text: text.trim(), replacedCount: 0, insertedCount: 0 };
      }

      const preset = INTENSITY_PRESETS[Number(intensity.value)];
      const scale = preset.scale;

      const mask = activeMask();
      if (mask === ModulationNone) {
        return { text: text.trim(), replacedCount: 0, insertedCount: 0 };
      }

      const drunk  = getList("drunk")  || { words: [], inserts: [] };
      const terror = getList("terror") || { words: [], inserts: [] };
      const head   = getList("head")   || { words: [], inserts: [] };

      const segments = splitSentences(text);

      let replacedCount = 0;
      let insertedCount = 0;

      const transformed = segments.map(seg => {
        const tokens = tokenize(seg);
        const wordIdxs = wordTokenIndexes(tokens);
        if (wordIdxs.length === 0) return seg;

        const targetTokenIndex = pick(wordIdxs);
        const targetWord = tokens[targetTokenIndex];
        const factor = lenFactor(targetWord);

        const mod = pickActiveModulation(mask);

        const applyOne = (tokenIndex, chosenMod, factorLocal=1.0) => {
          const w = tokens[tokenIndex];
          if (!w || !isWord(w)) return;

          if (chosenMod === ModulationHead) {
            const pool = head.inserts ?? [];
            const mutated = modHead(w, pool);
            if (mutated !== w) {
              tokens[tokenIndex] = `<em>${escapeHTML(mutated)}</em>`;
              insertedCount += 1;
            }
            return;
          }

          const isTerror = chosenMod === ModulationTerror;

          const dlChance  = (isTerror ? 0.075 : 0.033) * factorLocal * scale;
          const repChance = (isTerror ? 0.75  : 0.33 ) * factorLocal * scale;

          // 1) double-letter
          const dl = modDoubleLetters(w, dlChance);
          if (dl !== w) {
            tokens[tokenIndex] = `<em>${escapeHTML(dl)}</em>`;
            insertedCount += 1;
          }

          // 2) insert/replace
          const wordsPool   = (isTerror ? (terror.words ?? [])   : (drunk.words ?? []));
          const insertsPool = (isTerror ? (terror.inserts ?? []) : (drunk.inserts ?? []));

          const res = modInsertReplace(tokens, tokenIndex, repChance, wordsPool, insertsPool);
          if (res.didReplace) replacedCount += 1;
          if (res.didInsert)  insertedCount += 1;
        };

        // Action principale sur un mot pivot
        applyOne(targetTokenIndex, mod, factor);

        // Bonus "mot tr√®s long" (une seule fois)
        const longCandidates = wordIdxs.filter(i => i !== targetTokenIndex && (tokens[i] || "").length > 24);
        if (longCandidates.length > 0 && Math.random() < 0.35 * scale) {
          const idx2 = pick(longCandidates);
          const mod2 = pickActiveModulation(mask);
          applyOne(idx2, mod2, lenFactor(tokens[idx2]) * 1.1);
        }

        let rebuilt = tokens.join("").replace(/\s{2,}/g, " ");
        rebuilt = sprinkleExtraPunct(rebuilt, preset.sprinklePunct);
        return rebuilt;
      }).join("");

      return { text: transformed.replace(/\s{2,}/g, " ").trim(), replacedCount, insertedCount };
    }

    // ============
    // BUTTONS
    // ============
    document.getElementById("transformBtn").addEventListener("click", () => {
      const src = inputText.value || "";
      if (!src.trim()) {
        outputText.innerHTML = "";
        toast.textContent = "Entre du texte üôÇ";
        return;
      }

      const res = transformText(src);
      outputText.innerHTML = res.text;
      toast.textContent = "Transform√© ‚úÖ";
      setTimeout(() => toast.textContent = "", 1400);
    });

    document.getElementById("copyBtn").addEventListener("click", async () => {
      const plain = outputText.innerText || "";
      if (!plain.trim()) return;

      const btn = document.getElementById("copyBtn");
      try {
        await copyToClipboard(plain);
        toast.textContent = "Copie normale OK ‚úÖ";
        flash(btn);
      } catch {
        toast.textContent = "Copie impossible ‚ùå (navigateur/HTTPS)";
      } finally {
        setTimeout(() => toast.textContent = "", 1400);
      }
    });

    document.getElementById("copyForumBtn").addEventListener("click", async () => {
      const bb = outputToBBCode();
      if (!bb.trim()) return;

      const btn = document.getElementById("copyForumBtn");
      try {
        await copyToClipboard(bb);
        toast.textContent = "Copie forum (BBCode) OK ‚úÖ";
        flash(btn);
      } catch {
        toast.textContent = "Copie impossible ‚ùå (navigateur/HTTPS)";
      } finally {
        setTimeout(() => toast.textContent = "", 1400);
      }
    });
  </script>
</body>
</html>
